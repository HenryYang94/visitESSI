/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtvisitESSIFileFormat.C                           //
// ************************************************************************* //

#include <avtvisitESSIFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkPoints.h>

#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>


#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

using     std::string;

#include <vtkCellType.h>





// My includes
#include <hdf5.h>







// ****************************************************************************
//  Method: avtvisitESSIFileFormat constructor
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

avtvisitESSIFileFormat::avtvisitESSIFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1)
{
    // INITIALIZE DATA MEMBERS
    filename_string = filename;
    nnodes = 0;
    ncells = 0;
    nsteps = -1;

    initialized = false;
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************


//IMPLEMENT ME!
int
avtvisitESSIFileFormat::GetNTimesteps(void)
{
    if (nsteps < 0)
    {
        initialize();
        cout << "visitESSI: Getting time\n\n";
        //Get the time dimension
        hid_t id_time = H5Dopen2(id_file, "/time", H5P_DEFAULT);
        hid_t id_time_dataspace = H5Dget_space(id_time);
        hsize_t id_time_nvals  = H5Sget_simple_extent_npoints(id_time_dataspace);

        cout << "visitESSI: feioutput file contains " << id_time_nvals << " timesteps.\n\n";

        nsteps = id_time_nvals;
    }
    return nsteps;//YOU_MUST_DECIDE;
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::FreeUpResources(void)
{
    H5close();
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    initialize();
    //
    // CODE TO ADD A MESH
    //
    string meshname = "ESSIsim";
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_UNSTRUCTURED_MESH;
    // //
    // int nblocks = 1;//  <-- this must be 1 for MTSD
    // int block_origin = 0;
    // int spatial_dimension = 3;
    // int topological_dimension = 3;
    // double *extents = NULL;

    // // Here's the call that tells the meta-data object that we have a mesh:
    // //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    avtMeshMetaData *mmd = new avtMeshMetaData;
    mmd->name = meshname.c_str();
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 3;
    mmd->meshType = AVT_UNSTRUCTURED_MESH;
    mmd->numBlocks = 1;

    md->Add(mmd);


    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    string varname = "Tag";
    avtCentering cent = AVT_NODECENT;


    // sHere's the call that tells the meta-data object that we have a var:

    AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);


    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    varname = "Displacements";
    int vector_dim = 3;
    cent = AVT_NODECENT; // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    //
    //
    // Here's the call that tells the meta - data object that we have a var:
    //
    AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent, vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    varname = "Stress";
    int tensor_dim = 9;
    cent = AVT_UNKNOWN_CENT;

    varname = "Strain";
    AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent, tensor_dim);



    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or --
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    //
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

//IMPLEMENT ME!
vtkDataSet *
avtvisitESSIFileFormat::GetMesh(int timestate, const char *meshname)
{
    initialize();
    std::cout << "visitESSI: Getting Mesh. \n\n";

    int ndims  = 3;
    int origin = 0;
    herr_t status;

    //////////////////////////////////////////////////////////////////////////////////////////
    // Nodes
    //////////////////////////////////////////////////////////////////////////////////////////


    cout << "visitESSI: Reading Node Info\n\n";


    //Get the number of defined nodes
    hid_t id_nodes_coordinates                    = H5Dopen2(id_file, "/Model/Nodes/Coordinates", H5P_DEFAULT);
    hid_t id_coordinates_dataspace                = H5Dget_space(id_nodes_coordinates);
    hsize_t id_nodes_coordinates_nvals            = H5Sget_simple_extent_npoints(id_coordinates_dataspace);
    nnodes                                        = static_cast<int> (id_nodes_coordinates_nvals) / 3;


    //Get number of maximum possibly defined tags :/
    hid_t id_nodes_index_to_coordinates           = H5Dopen2(id_file, "/Model/Nodes/Index_to_Coordinates", H5P_DEFAULT);
    hid_t id_nodes_index_to_coordinates_dataspace = H5Dget_space(id_nodes_index_to_coordinates);
    hsize_t nodes_number_of_tags_max              = H5Sget_simple_extent_npoints(id_nodes_index_to_coordinates_dataspace);

    //Get the index to coordinates
    int *index_to_coordinates = new int[nodes_number_of_tags_max];
    status = H5Dread(id_nodes_index_to_coordinates, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_coordinates_dataspace, H5P_DEFAULT,
                     index_to_coordinates);


    //Form an array that transforms node "tags" to connectivity indexes
    int *tags2pointnumbers = new int[nodes_number_of_tags_max];
    for (int i = 0; i < nodes_number_of_tags_max; i++)
    {
        if (index_to_coordinates[i] > 0)
        {
            tags2pointnumbers[i] = index_to_coordinates[i] / 3;
        }
        else
        {
            tags2pointnumbers[i] = -1;
        }
    }



    // Write the nodes

    //
    // Create the vtkPoints object and copy points into it.
    //
    vtkPoints *points = vtkPoints::New();
    points->SetNumberOfPoints(nnodes);
    float *pts        = (float *) points->GetVoidPointer(0);

    //Read values of coordinates from HDF5 directly into the VTK pts pointer
    const hsize_t dims[1]          = {nnodes * 3};
    hid_t memspace                 = H5Screate_simple(1, dims, dims);
    status = H5Dread(id_nodes_coordinates, H5T_NATIVE_FLOAT, memspace, id_coordinates_dataspace, H5P_DEFAULT,
                     pts);

    cout << "visitESSI: Done reading nodes. Read " << nnodes << " nodes values.\n\n";


    //Free up memory.
    delete [] index_to_coordinates;
    H5Dclose(id_nodes_coordinates);
    H5Sclose(id_coordinates_dataspace);
    H5Dclose(id_nodes_index_to_coordinates);
    H5Sclose(id_nodes_index_to_coordinates_dataspace);


    //////////////////////////////////////////////////////////////////////////////////////////
    //    ELEMENTS
    //////////////////////////////////////////////////////////////////////////////////////////
    cout << "visitESSI: Reading Element Info\n\n";


    //Get the number of elements (ncells)
    hid_t id_elements_nnodes = H5Dopen2(id_file, "/Model/Elements/Number_of_Nodes", H5P_DEFAULT);
    hid_t id_elements_nnodes_dataspace = H5Dget_space(id_elements_nnodes);
    hsize_t id_elements_nnodes_nvals  = H5Sget_simple_extent_npoints(id_elements_nnodes_dataspace);

    int *elements_nnodes  = new int[id_elements_nnodes_nvals];
    status = H5Dread(id_elements_nnodes, H5T_NATIVE_INT, H5S_ALL   , id_elements_nnodes_dataspace, H5P_DEFAULT,
                     elements_nnodes);

    //Count number of "tags" which are > 0 (gives ncells)
    for (int i = 0; i < id_elements_nnodes_nvals; i++)
    {
        if (elements_nnodes[i] > 8)
        {
            ncells++;
        }
    }
    H5Dclose(id_elements_nnodes);
    H5Sclose(id_elements_nnodes_dataspace);



    //Get the  connectivity
    hid_t id_elements_connectivity           = H5Dopen2(id_file, "/Model/Elements/Connectivity", H5P_DEFAULT);
    hid_t id_elements_connectivity_dataspace = H5Dget_space(id_elements_connectivity);
    hsize_t id_elements_connectivity_nvals   = H5Sget_simple_extent_npoints(id_elements_connectivity_dataspace);

    int *connectivity  = new int[id_elements_connectivity_nvals];
    status = H5Dread(id_elements_connectivity, H5T_NATIVE_INT, H5S_ALL   , id_elements_connectivity_dataspace, H5P_DEFAULT,
                     connectivity);
    H5Dclose(id_elements_connectivity);
    H5Sclose(id_elements_connectivity_dataspace);




    //
    // Create a vtkUnstructuredGrid to contain the point cells.
    //
    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();

    ugrid  -> SetPoints(points);
    points -> Delete();
    ugrid  -> Allocate(ncells);

    vtkIdType verts[8];


    //Loop over elements and add them
    int count = 0;
    for (int i = 0; i < ncells; ++i)
    {
        int cellType = 0;
        int nverts = 0;

        if (elements_nnodes[i] > 0)
        {

            if (elements_nnodes[i] == 8)
            {
                nverts = 8;
                cellType == VTK_HEXAHEDRON;
            }
            else if (elements_nnodes[i] == 2)
            {
                nverts = 2;
                cellType = VTK_LINE;
            }
            else if (elements_nnodes[i] == 4)
            {
                nverts = 4;
                cellType = VTK_QUAD;
            }
            else if (elements_nnodes[i] == 1)
            {
                nverts = 1;
                cellType = VTK_VERTEX;
            }

            // Make a list of node indices that make up the cell.
            for (int j = 0; j < nverts; ++j)
            {
                int thisvertextnumber;
                thisvertextnumber = tags2pointnumbers[connectivity[count++]];
                if (thisvertextnumber > 0)
                {
                    verts[j] = thisvertextnumber;
                }
                else
                {
                    //Something went wrong
                    // EXCEPTION0(InvalidVariableException, meshname);
                }
            }
            // conn += nverts;
            // Insert the cell into the mesh.
            ugrid->InsertNextCell(cellType, nverts, verts);
        }
    }
    delete [] connectivity;
    delete [] tags2pointnumbers;
    delete [] elements_nnodes;
    return ugrid;

    /**/
    // return 0;
}










// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

//IMPLEMENT ME!
vtkDataArray *
avtvisitESSIFileFormat::GetVar(int timestate, const char *varname)
{
    return 0;//YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************

//IMPLEMENT ME!
vtkDataArray *
avtvisitESSIFileFormat::GetVectorVar(int timestate, const char *varname)
{
    // return 0; //YOU MUST IMPLEMENT THIS
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    std::string name = varname;

    cout << "visitESSI: Trying to get " << varname << ". \n\n";

    if ( name.compare("Displacements") == 0)
    {
        cout << "visitESSI: Getting displacements. \n\n";
        int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
        int ntuples = nnodes; // this is the number of entries in the variable.
        int ucomps = 3;


        vtkFloatArray *rv = vtkFloatArray::New();
        rv->SetNumberOfComponents(ucomps);
        rv->SetNumberOfTuples(ntuples);

        cout << "visitESSI: Opening HDF5 file. \n";
        //Get the  connectivity
        hid_t id_nodes_index_to_output = H5Dopen2(id_file, "/Model/Nodes/Index_to_Nodes_Output", H5P_DEFAULT);
        hid_t id_nodes_index_to_output_dataspace = H5Dget_space(id_nodes_index_to_output);
        hsize_t id_nodes_index_to_output_nvals  = H5Sget_simple_extent_npoints(id_nodes_index_to_output_dataspace);

        int *index_to_output  = new int[id_nodes_index_to_output_nvals];

        cout << "visitESSI: Reading displacements index. \n";
        H5Dread(id_nodes_index_to_output, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_output_dataspace, H5P_DEFAULT,
                index_to_output);
        H5Dclose(id_nodes_index_to_output);
        H5Sclose(id_nodes_index_to_output_dataspace);
        cout << "            Done!                       \n";


        cout << "visitESSI: Getting extents \n";
        //Open up displacements for reading
        hid_t id_nodes_displacements = H5Dopen2(id_file, "/Model/Nodes/Displacements", H5P_DEFAULT);
        hid_t id_nodes_displacements_dataspace = H5Dget_space(id_nodes_displacements);
        int node_displacements_ndims = H5Sget_simple_extent_ndims(id_nodes_displacements_dataspace);
        cout << "node_displacements_ndims = " << node_displacements_ndims << endl;

        hsize_t dims[node_displacements_ndims];
        hsize_t maxdims[node_displacements_ndims];
        H5Sget_simple_extent_dims(id_nodes_displacements_dataspace, dims, maxdims );

        cout << "                          Got dims" << endl;

        for (int i = 0; i < node_displacements_ndims; i++)
        {
            cout << "      dim[" << i << "] = " << dims[i] <<  "\n";
        }


        //Create description of data in memory
        hsize_t datadims[1] = {dims[0]};
        hid_t memspace  = H5Screate_simple(1, datadims, datadims);

        cout << "visitESSI: Selecting.\n";

        //Try to get all the displacements now
        float *displacements = new float[dims[0]];

        const hsize_t start[2] = {0, timestate};
        const hsize_t stride[2] = {1, 1};
        const hsize_t count[2] = {dims[0], 1};
        const hsize_t block[2] = {1, 1};

        H5Sselect_hyperslab( id_nodes_displacements_dataspace, H5S_SELECT_SET, start, stride, count, block );

        cout << "visitESSI: Reading displacements for this step into memory. \n";
        H5Dread(id_nodes_displacements, H5T_NATIVE_FLOAT, memspace   , id_nodes_displacements_dataspace, H5P_DEFAULT,
                displacements);

        H5Dclose(id_nodes_displacements);
        H5Sclose(id_nodes_displacements_dataspace);
        H5Sclose(memspace);

        cout << "visitESSI: Loading displacements into VTK object. \n";
        float *one_entry = new float[ucomps];
        float *d = displacements;
        for (int i = 0 ; i < ntuples ; i++)
        {
            one_entry[0] = *(d++);
            one_entry[1] = *(d++);
            one_entry[2] = *(d++);
            rv->SetTuple(i, one_entry);
        }

        delete [] one_entry;
        delete [] index_to_output;
        delete [] displacements;



        return rv;
    }
    else
    {
        cout << "visitESSI: Variable '" << name <<  "' not available. \n\n";
    }
    return 0;
}






// Override this method in your reader
void
avtvisitESSIFileFormat::ActivateTimestep()
{
    initialize();
}




void avtvisitESSIFileFormat::initialize()
{
    if (!initialized)
    {
        bool okay = false;

        cout << "visitESSI: Opening: " << filename_string << "\n\n";
        id_file = H5Fopen( filename_string.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
        cout << "Got id  to file: " << id_file << "\n\n";

        if (id_file >= 0)
        {
            okay = true;
        }

        if (!okay)
        {
            cout << "visitESSI: Could not open file.\n\n";
            EXCEPTION1(InvalidDBTypeException,
                       "The file could not be opened");
        }

        initialized = true;
    }
}