/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtvisitESSIFileFormat.C                           //
// ************************************************************************* //

#include <avtvisitESSIFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkPoints.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

#include <InvalidDBTypeException.h>

using     std::string;
#include <vtkCellType.h>





// My includes
#include <hdf5.h>


// ****************************************************************************
//  Method: avtvisitESSIFileFormat constructor
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

avtvisitESSIFileFormat::avtvisitESSIFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    // INITIALIZE DATA MEMBERS
    filename_string = filename;
    nnodes = 0;
    ncells = 0;
    nsteps = -1;

    returned_gaussmesh_already = false;
    returned_mainmesh_already = false;

    mainmesh_data = NULL;
    gaussmesh_data = NULL;

    initialized = false;
}




// ****************************************************************************
//  Method: avtvisitESSIFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::FreeUpResources(void)
{
    // H5close();
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    initialize();
    //
    // CODE TO ADD A MESH
    //
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_UNSTRUCTURED_MESH;
    // //
    // int nblocks = 1;//  <-- this must be 1 for MTSD
    // int block_origin = 0;
    // int spatial_dimension = 3;
    // int topological_dimension = 3;
    // double *extents = NULL;

    // // Here's the call that tells the meta-data object that we have a mesh:
    // //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    mainmesh = "ESSI Domain Mesh";
    avtMeshMetaData *mmd = new avtMeshMetaData;
    mmd->name = mainmesh.c_str();
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 3;
    mmd->meshType = AVT_UNSTRUCTURED_MESH;
    mmd->numBlocks = 1;

    md->Add(mmd);

    gaussmesh = "Gauss Points";
    mmd = new avtMeshMetaData;
    mmd->name = gaussmesh.c_str();
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 0;
    mmd->meshType = AVT_POINT_MESH;
    mmd->numBlocks = 1;

    md->Add(mmd);


    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    string varname = "Tag";
    avtCentering cent = AVT_NODECENT;


    // sHere's the call that tells the meta-data object that we have a var:

    AddScalarVarToMetaData(md, varname, mainmesh, cent);


    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    varname = "Generalized Displacements";
    int vector_dim = 3;
    cent = AVT_NODECENT; // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    //
    //
    // Here's the call that tells the meta - data object that we have a var:
    //
    AddVectorVarToMetaData(md, varname, mainmesh, cent, vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    varname = "Stress";
    int tensor_dim = 9;
    cent = AVT_NODECENT;
    AddTensorVarToMetaData(md, varname, gaussmesh, cent, tensor_dim);

    varname = "Strain";
    AddTensorVarToMetaData(md, varname, gaussmesh, cent, tensor_dim);



    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or --
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    //
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataSet *
avtvisitESSIFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    initialize();
    // std::cout << "visitESSI: Getting Mesh: -> " <<  meshname <<  "\n\n" ;

    // string mname = meshname;



    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    //   MAIN MESH
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================



    if (strcmp(meshname, mainmesh.c_str()) == 0 )
    {
        // If this is the first time reading the mesh data -> load it into memory!!
        if (mainmesh_data == NULL)
        {
            int ndims  = 3;
            int origin = 0;
            // ncells = 0;
            herr_t status;

            // float *mainmesh_pts;
            int *connectivity;
            int *tags2pointnumbers;
            int *elements_nnodes;

            hsize_t id_elements_nnodes_nvals;

            //////////////////////////////////////////////////////////////////////////////////////////
            // Nodes
            //////////////////////////////////////////////////////////////////////////////////////////


            cout << "visitESSI: Reading Node Info\n\n";


            //Get the number of defined nodes


            hid_t id_nodes_coordinates                    = H5Dopen2(id_file, "/Model/Nodes/Coordinates", H5P_DEFAULT);
            hid_t id_coordinates_dataspace                = H5Dget_space(id_nodes_coordinates);
            hsize_t id_nodes_coordinates_nvals            = H5Sget_simple_extent_npoints(id_coordinates_dataspace);
            // nnodes                                        = static_cast<int> (id_nodes_coordinates_nvals) / 3;
            //Get number of maximum possibly defined tags :/
            hid_t id_nodes_index_to_coordinates           = H5Dopen2(id_file, "/Model/Nodes/Index_to_Coordinates", H5P_DEFAULT);
            hid_t id_nodes_index_to_coordinates_dataspace = H5Dget_space(id_nodes_index_to_coordinates);
            hsize_t nodes_number_of_tags_max              = H5Sget_simple_extent_npoints(id_nodes_index_to_coordinates_dataspace);

            //Get the index to coordinates
            int *index_to_coordinates = new int[nodes_number_of_tags_max];
            status = H5Dread(id_nodes_index_to_coordinates, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_coordinates_dataspace, H5P_DEFAULT,
                             index_to_coordinates);



            //Form an array that transforms node "tags" to connectivity indexes
            tags2pointnumbers = new int[nodes_number_of_tags_max];
            for (int i = 0; i < nodes_number_of_tags_max; i++)
            {
                if (index_to_coordinates[i] >= 0)
                {
                    tags2pointnumbers[i] = index_to_coordinates[i] / 3;

                }
                else
                {
                    tags2pointnumbers[i] = -1;
                }
            }


            //
            // Create the vtkPoints object and copy points into it.
            //
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(nnodes);
            float *pts        = (float *) points->GetVoidPointer(0);



            // mainmesh_pts = new float[nnodes * 3];

            //Read values of coordinates from HDF5 directly into the VTK pts pointer
            const hsize_t dims[1]          = {nnodes * 3};
            hid_t memspace                 = H5Screate_simple(1, dims, dims);
            status = H5Dread(id_nodes_coordinates, H5T_NATIVE_FLOAT, memspace, id_coordinates_dataspace, H5P_DEFAULT,
                             pts);


            cout << "visitESSI: Done reading nodes. Read " << nnodes << " nodes values.\n\n";


            //Free up memory.
            delete [] index_to_coordinates;
            H5Dclose(id_nodes_coordinates);
            H5Sclose(id_coordinates_dataspace);
            H5Dclose(id_nodes_index_to_coordinates);
            H5Sclose(id_nodes_index_to_coordinates_dataspace);


            //////////////////////////////////////////////////////////////////////////////////////////
            //    ELEMENTS
            //////////////////////////////////////////////////////////////////////////////////////////
            cout << "visitESSI: Reading Element Info\n\n";


            //Get the number of elements (ncells)
            hid_t id_elements_nnodes = H5Dopen2(id_file, "/Model/Elements/Number_of_Nodes", H5P_DEFAULT);
            hid_t id_elements_nnodes_dataspace = H5Dget_space(id_elements_nnodes);
            id_elements_nnodes_nvals  = H5Sget_simple_extent_npoints(id_elements_nnodes_dataspace);



            elements_nnodes  = new int[id_elements_nnodes_nvals];
            status = H5Dread(id_elements_nnodes, H5T_NATIVE_INT, H5S_ALL   , id_elements_nnodes_dataspace, H5P_DEFAULT,
                             elements_nnodes);

            //Count number of "tags" which are > 0 (gives ncells)
            // for (int i = 0; i < id_elements_nnodes_nvals; i++)
            // {
            //     if (elements_nnodes[i] >=  0)
            //     {
            //         ncells++;
            //     }
            // }
            H5Dclose(id_elements_nnodes);
            H5Sclose(id_elements_nnodes_dataspace);


            cout << "visitESSI: Mesh has " << ncells <<  " elements. \n\n";

            cout << "visitESSI: Reading connectivity \n\n";

            //Get the  connectivity
            hid_t id_elements_connectivity           = H5Dopen2(id_file, "/Model/Elements/Connectivity", H5P_DEFAULT);
            hid_t id_elements_connectivity_dataspace = H5Dget_space(id_elements_connectivity);
            hsize_t id_elements_connectivity_nvals   = H5Sget_simple_extent_npoints(id_elements_connectivity_dataspace);

            connectivity  = new int[id_elements_connectivity_nvals];
            status = H5Dread(id_elements_connectivity, H5T_NATIVE_INT, H5S_ALL   , id_elements_connectivity_dataspace, H5P_DEFAULT,
                             connectivity);
            H5Dclose(id_elements_connectivity);
            H5Sclose(id_elements_connectivity_dataspace);

            returned_mainmesh_already = true;

            cout << "visitESSI: Done! \n\n";


            cout << "visitESSI : Generating VTK nodes\n";


            //
            // Create a vtkUnstructuredGrid to contain the point cells.
            //
            mainmesh_data = vtkUnstructuredGrid::New();
            mainmesh_data  -> SetPoints(points);
            points -> Delete();
            mainmesh_data  -> Allocate(ncells);

            vtkIdType verts[27];



            // Converters from ESSI node conventions to VTK

            //                               0  1  2  3  4  5  6  7
            int essi_to_vtk_8nodebrick[8] = {4, 5, 6, 7, 0, 1, 2, 3};
            //                                  0   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26
            int essi_to_vtk_27nodebrick[27] = { 6,  5,  4,  7,  2,  1,  0,  3,  13, 12, 15,  14,   9,   8,  11,  10,  18,  17,  16,  19,  23,  21,  22,  24,  26,  25,  20 };

            //Loop over elements and add them
            int count = 0;
            int number_of_added_elements = 0;
            int *access_order;
            bool found = false;

            for (int i = 0; i < id_elements_nnodes_nvals; ++i)
            {
                int cellType = 0;
                int nverts = 0;
                found = false;

                if (elements_nnodes[i] > 0)
                {

                    number_of_added_elements++;
                    if (elements_nnodes[i] == 8)
                    {
                        nverts = 8;
                        cellType = VTK_HEXAHEDRON;
                        access_order = essi_to_vtk_8nodebrick;
                        found = true;
                    }
                    else if (elements_nnodes[i] == 27)
                    {
                        nverts = 27;
                        cellType = VTK_TRIQUADRATIC_HEXAHEDRON;
                        access_order = essi_to_vtk_27nodebrick;
                        found = true;
                    }
                    else if (elements_nnodes[i] == 4)
                    {
                        nverts = 4;
                        cellType = VTK_QUAD;
                    }
                    else if (elements_nnodes[i] == 1)
                    {
                        nverts = 1;
                        cellType = VTK_VERTEX;
                    }
                    if (found)
                    {
                        // Make a list of node indices that make up the cell..
                        int essi_node_number;
                        int visit_vertex_number;
                        for (int j = 0; j < nverts; ++j)
                        {
                            essi_node_number = connectivity[count + access_order[j]];
                            visit_vertex_number = tags2pointnumbers[essi_node_number];

                            if (visit_vertex_number >= 0)
                            {
                                verts[j] = visit_vertex_number;
                            }
                            else
                            {
                                //Something went wrong
                                cerr << "!!!! visitESSI - something went wrong\n\n";
                                // EXCEPTION0(InvalidVariableException, meshname);
                            }
                        }
                    }
                    count += nverts;
                    mainmesh_data->InsertNextCell(cellType, nverts, verts);
                }
            }
            cout << "visitESSI: Added " << number_of_added_elements << " elements of " << ncells << " total available.\n\n";
        }

        mainmesh_data->Register(NULL);
        return mainmesh_data;
    }   //Ends Brick Elements Mesh





    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    //   GAUSS POINT MESH
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================


    else if (strcmp(meshname, gaussmesh.c_str()) == 0)
    {
        if (gaussmesh_data == NULL)
        {
            int ndims  = 3;
            int origin = 0;
            herr_t status;


            cout << "visitESSI: Reading GP Info\n\n";

            //Get the number of defined gausspoints
            hid_t id_gausspoints_coordinates                    = H5Dopen2(id_file, "/Model/Elements/Gauss_Point_Coordinates", H5P_DEFAULT);
            hid_t id_coordinates_dataspace                = H5Dget_space(id_gausspoints_coordinates);
            hsize_t id_gausspoints_coordinates_nvals            = H5Sget_simple_extent_npoints(id_coordinates_dataspace);
            ngauss                                        = static_cast<int> (id_gausspoints_coordinates_nvals) / 3;


            //Get number of maximum possibly defined tags :/
            hid_t id_gausspoints_index_to_coordinates           = H5Dopen2(id_file, "/Model/Elements/Index_to_Gauss_Point_Coordinates", H5P_DEFAULT);
            hid_t id_gausspoints_index_to_coordinates_dataspace = H5Dget_space(id_gausspoints_index_to_coordinates);
            hsize_t gausspoints_number_of_tags_max              = H5Sget_simple_extent_npoints(id_gausspoints_index_to_coordinates_dataspace);

            //Get the index to coordinates of GPS
            int *index_to_coordinates = new int[gausspoints_number_of_tags_max];
            status = H5Dread(id_gausspoints_index_to_coordinates, H5T_NATIVE_INT, H5S_ALL   , id_gausspoints_index_to_coordinates_dataspace, H5P_DEFAULT,
                             index_to_coordinates);

            //Get number of Gauss points per element
            hid_t id_number_of_gausspoints           = H5Dopen2(id_file, "/Model/Elements/Number_of_Gauss_Points", H5P_DEFAULT);
            hid_t id_number_of_gausspoints_dataspace = H5Dget_space(id_number_of_gausspoints);


            //Get the number of GPs
            number_of_gauss_points = new int[gausspoints_number_of_tags_max];
            status = H5Dread(id_number_of_gausspoints, H5T_NATIVE_INT, H5S_ALL   , id_number_of_gausspoints_dataspace, H5P_DEFAULT,
                             number_of_gauss_points);



            //Build an index that relates number of a gauss point to the element it belongs to
            gauss_to_element_tag = new int[ngauss];
            int gaussnumber = 0;

            for (int tag = 0; tag < gausspoints_number_of_tags_max; tag++)
            {
                if (index_to_coordinates[tag] >= 0)
                {
                    int number_of_gauss_points_for_this_element;
                    number_of_gauss_points_for_this_element = number_of_gauss_points[tag];
                    for (int g = 0; g < number_of_gauss_points_for_this_element; g++)
                    {
                        gauss_to_element_tag[gaussnumber] = tag;
                        gaussnumber++;
                    }
                }
            }


            // Write the gausspoints
            vtkPoints *points = vtkPoints::New();

            points->SetNumberOfPoints(ngauss);
            float *pts        = (float *) points->GetVoidPointer(0);

            //Read values of coordinates from HDF5 directly into the VTK pts pointer
            const hsize_t dims[1]          = {ngauss * 3};
            hid_t memspace                 = H5Screate_simple(1, dims, dims);
            status = H5Dread(id_gausspoints_coordinates, H5T_NATIVE_FLOAT, memspace, id_coordinates_dataspace, H5P_DEFAULT,
                             pts);

            cout << "visitESSI: Done reading Gauss Points. Read " << ngauss << " GP coordinate values.\n\n";


            //Free up memory.
            delete [] index_to_coordinates;
            // delete [] number_of_gauss_points;
            H5Dclose(id_gausspoints_coordinates);
            H5Sclose(id_coordinates_dataspace);
            H5Dclose(id_gausspoints_index_to_coordinates);
            H5Sclose(id_gausspoints_index_to_coordinates_dataspace);
            H5Dclose(id_number_of_gausspoints);
            H5Sclose(id_number_of_gausspoints_dataspace);

            //
            // Create a vtkUnstructuredGrid to contain the point cells.
            //
            gaussmesh_data = vtkUnstructuredGrid::New();
            gaussmesh_data->SetPoints(points);
            points->Delete();
            gaussmesh_data->Allocate(ngauss);
            vtkIdType onevertex;
            for (int i = 0; i < ngauss; ++i)
            {
                onevertex = i;
                gaussmesh_data->InsertNextCell(VTK_VERTEX, 1, &onevertex);
            }
        }
        gaussmesh_data->Register(NULL);
        return gaussmesh_data;
    }

}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtvisitESSIFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    return 0;//YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtvisitESSIFileFormat::GetVectorVar(int timestate, int domain, const char *varname)
{
    cout << "visitESSI: Trying to get " << varname << " at t = " << timestate << "  \n\n";

    if (strcmp(varname, "Generalized Displacements") == 0)
    {
        cout << "visitESSI: Getting generalized displacements. \n\n";
        int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
        int ntuples = nnodes; // this is the number of entries in the variable.
        int ucomps = 3;


        vtkFloatArray *rv = vtkFloatArray::New();
        rv->SetNumberOfComponents(ucomps);
        rv->SetNumberOfTuples(ntuples);

        //Get the  connectivity
        hid_t id_nodes_index_to_output = H5Dopen2(id_file, "/Model/Nodes/Index_to_Generalized_Displacements", H5P_DEFAULT);
        hid_t id_nodes_index_to_output_dataspace = H5Dget_space(id_nodes_index_to_output);
        hsize_t id_nodes_index_to_output_nvals  = H5Sget_simple_extent_npoints(id_nodes_index_to_output_dataspace);
        int *index_to_output  = new int[id_nodes_index_to_output_nvals];
        H5Dread(id_nodes_index_to_output, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_output_dataspace, H5P_DEFAULT,
                index_to_output);

        H5Dclose(id_nodes_index_to_output);
        H5Sclose(id_nodes_index_to_output_dataspace);



        //Open up displacements for reading
        hid_t id_nodes_displacements = H5Dopen2(id_file, "/Model/Nodes/Generalized_Displacements", H5P_DEFAULT);
        hid_t id_nodes_displacements_dataspace = H5Dget_space(id_nodes_displacements);
        int node_displacements_ndims = H5Sget_simple_extent_ndims(id_nodes_displacements_dataspace);
        hsize_t dims[node_displacements_ndims];
        hsize_t maxdims[node_displacements_ndims];
        H5Sget_simple_extent_dims(id_nodes_displacements_dataspace, dims, maxdims );


        //Create description of data in memory
        hsize_t datadims[1] = {dims[0]};
        hid_t memspace  = H5Screate_simple(1, datadims, datadims);

        //Try to get all the displacements now
        float *displacements = new float[dims[0]];

        const hsize_t start[2] = {0, timestate};
        const hsize_t stride[2] = {1, 1};
        const hsize_t count[2] = {dims[0], 1};
        const hsize_t block[2] = {1, 1};

        H5Sselect_hyperslab( id_nodes_displacements_dataspace, H5S_SELECT_SET, start, stride, count, block );
        H5Dread(id_nodes_displacements, H5T_NATIVE_FLOAT, memspace   , id_nodes_displacements_dataspace, H5P_DEFAULT,
                displacements);

        //Creanup
        H5Dclose(id_nodes_displacements);
        H5Sclose(id_nodes_displacements_dataspace);
        H5Sclose(memspace);

        //Write the data to VTK
        float *one_entry = new float[ucomps];
        float *d = displacements;
        for (int i = 0 ; i < ntuples ; i++)
        {
            one_entry[0] = *(d++);
            one_entry[1] = *(d++);
            one_entry[2] = *(d++);
            rv->SetTuple(i, one_entry);
        }

        delete [] one_entry;
        delete [] index_to_output;
        delete [] displacements;



        return rv;
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================

    else if (strcmp(varname, "Stress") == 0)
    {
        cout << "visitESSI: Getting stress. \n\n";
        int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
        int ntuples = ngauss; // this is the number of entries in the variable.
        int ucomps = 9;


        vtkFloatArray *rv = vtkFloatArray::New();
        rv->SetNumberOfComponents(ucomps);
        rv->SetNumberOfTuples(ntuples);


        // Read output index
        hid_t id_elements_index_to_outputs = H5Dopen2(id_file, "/Model/Elements/Index_to_Outputs", H5P_DEFAULT);
        hid_t id_elements_index_to_outputs_dataspace = H5Dget_space(id_elements_index_to_outputs);
        hsize_t id_elements_index_to_outputs_nvals  = H5Sget_simple_extent_npoints(id_elements_index_to_outputs_dataspace);
        int *index_to_outputs  = new int[id_elements_index_to_outputs_nvals];
        H5Dread(id_elements_index_to_outputs, H5T_NATIVE_INT, H5S_ALL   , id_elements_index_to_outputs_dataspace, H5P_DEFAULT,
                index_to_outputs);
        H5Dclose(id_elements_index_to_outputs);
        H5Sclose(id_elements_index_to_outputs_dataspace);


        // Read output
        hid_t id_elements_outputs = H5Dopen2(id_file, "/Model/Elements/Outputs", H5P_DEFAULT);
        hid_t id_elements_outputs_dataspace = H5Dget_space(id_elements_outputs);
        int elements_outputs_ndims = H5Sget_simple_extent_ndims(id_elements_outputs_dataspace);
        hsize_t dims[elements_outputs_ndims];
        hsize_t maxdims[elements_outputs_ndims];
        H5Sget_simple_extent_dims(id_elements_outputs_dataspace, dims, maxdims );


        //Create description of data in memory
        hsize_t datadims[1] = {dims[0]};
        hid_t memspace  = H5Screate_simple(1, datadims, datadims);


        //Try to get all the outputs (from all elements) now
        float *outputs = new float[dims[0]];

        const hsize_t start[2] = {0, timestate};
        const hsize_t stride[2] = {1, 1};
        const hsize_t count[2] = {dims[0], 1};
        const hsize_t block[2] = {1, 1};

        H5Sselect_hyperslab( id_elements_outputs_dataspace, H5S_SELECT_SET, start, stride, count, block );
        H5Dread(id_elements_outputs, H5T_NATIVE_FLOAT, memspace   , id_elements_outputs_dataspace, H5P_DEFAULT,
                outputs);

        H5Dclose(id_elements_outputs);
        H5Sclose(id_elements_outputs_dataspace);
        H5Sclose(memspace);

        // cout << "ncells = " << ncells << endl;
        float *one_entry = new float[ucomps];
        int gptag = 0;
        int order[9] = { 0 , 3,  4 , 3, 1, 5, 4, 5, 2 }; // This converts 6 component symmetric stress to 9 component general tensor... matrix is filled row-wise.
        float maxstress = 0;
        float minstress;
        for (int tag = 0 ; tag < ncells ; tag++)
        {
            int pos = index_to_outputs[tag];
            int number_of_gauss_points_for_this_element = number_of_gauss_points[tag];
            for (int gp = 0; gp < number_of_gauss_points_for_this_element; gp++)
            {
                // float *s = outputs[ pos + 18 * gp + 12]; // 18 is the number of outputs per gauss-point first 6 are strains, next 6 are plastic strains and final 6 are stresses (hence the +12)
                float *s = outputs + pos + 18 * gp + 12; // 18 is the number of outputs per gauss-point first 6 are strains, next 6 are plastic strains and final 6 are stresses (hence the +12)
                for (int i = 0; i < 9; i++)
                {
                    one_entry[i] = *(s + order[i]);
                }

                rv->SetTuple(gptag, one_entry);
                gptag++;
            }
        }

        delete [] one_entry;
        delete [] index_to_outputs;
        delete [] outputs;

        return rv;


    }
    else
    {
        cout << "visitESSI : Variable '" << varname <<  "' not available. \n\n";
    }
    return 0;
}






// Override this method in your reader
void
avtvisitESSIFileFormat::ActivateTimestep()
{
    initialize();
}




void avtvisitESSIFileFormat::initialize()
{
    if (!initialized)
    {
        bool okay = false;

        cout << "visitESSI : Opening : " << filename_string << "\n\n";
        id_file = H5Fopen( filename_string.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
        cout << "Got id  to file : " << id_file << "\n\n";

        if (id_file >= 0)
        {
            okay = true;
        }

        if (!okay)
        {
            cout << "visitESSI : Could not open file.\n\n";
            EXCEPTION1(InvalidDBTypeException,
                       "The file could not be opened");
        }

        //Read number of time steps
        hid_t id_num_tsteps = H5Dopen2(id_file, "/Number_of_Time_Steps", H5P_DEFAULT);
        hid_t id_num_tsteps_dataspace = H5Dget_space(id_num_tsteps);
        H5Dread(id_num_tsteps, H5T_NATIVE_INT, H5S_ALL   , id_num_tsteps_dataspace, H5P_DEFAULT,
                &nsteps);
        H5Dclose(id_num_tsteps);
        H5Sclose(id_num_tsteps_dataspace);

        //Read number of elements
        hid_t id_num_elements = H5Dopen2(id_file, "/Number_of_Elements", H5P_DEFAULT);
        hid_t id_num_elements_dataspace = H5Dget_space(id_num_elements);
        H5Dread(id_num_elements, H5T_NATIVE_INT, H5S_ALL   , id_num_elements_dataspace, H5P_DEFAULT,
                &ncells);
        H5Dclose(id_num_elements);
        H5Sclose(id_num_elements_dataspace);

        //Read number of nodes
        hid_t id_num_nodes = H5Dopen2(id_file, "/Number_of_Nodes", H5P_DEFAULT);
        hid_t id_num_nodes_dataspace = H5Dget_space(id_num_nodes);
        H5Dread(id_num_nodes, H5T_NATIVE_INT, H5S_ALL   , id_num_nodes_dataspace, H5P_DEFAULT,
                &nnodes);
        H5Dclose(id_num_nodes);
        H5Sclose(id_num_nodes_dataspace);

        cout << "Number of time-steps = " << nsteps << endl;
        cout << "Number of nodes      = " << nnodes << endl;
        cout << "Number of elements   = " << ncells << endl;

        PopulateTimeAndNSteps();

        initialized = true;
    }
}




void
avtvisitESSIFileFormat::GetTime(std::vector<double> &times)
{
    if (nsteps < 0)
    {
        PopulateTimeAndNSteps();
    }
    times = t;
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************


//IMPLEMENT ME!
int
avtvisitESSIFileFormat::GetNTimesteps(void)
{
    if (nsteps < 0)
    {
        PopulateTimeAndNSteps();
    }
    return nsteps;
}



void avtvisitESSIFileFormat::PopulateTimeAndNSteps()
{
    if (nsteps < 0)
    {

        initialize();
        cout << "visitESSI : Getting time\n\n";
        //Get the time dimension
        hid_t id_time = H5Dopen2(id_file, "/time", H5P_DEFAULT);
        hid_t id_time_dataspace = H5Dget_space(id_time);
        hsize_t id_time_nvals  = H5Sget_simple_extent_npoints(id_time_dataspace);


        cout << "visitESSI : feioutput file contains " << id_time_nvals << " timesteps.\n\n";

        if (nsteps != id_time_nvals)
        {
            cerr << "Something wrong nsteps != id_time_nvals  ( " << nsteps << " != " << id_time_nvals << ") \n\n";
        }
        // nsteps = id_time_nvals;

        double *vals = new double[nsteps] ;
        H5Dread(id_time, H5T_NATIVE_DOUBLE, H5S_ALL   , id_time_dataspace, H5P_DEFAULT,
                vals);

        // Store the times in the vector.
        for (int i = 0; i < nsteps; ++i)
        {
            t.push_back(vals[i]);
        }
        delete [] vals;
    }
}
